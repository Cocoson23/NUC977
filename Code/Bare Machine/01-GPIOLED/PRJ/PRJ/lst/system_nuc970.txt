; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\system_nuc970.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\system_nuc970.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931 -I..\..\Driver\Include -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\Toshiba -D__UVISION_VERSION=524 --omf_browse=.\obj\system_nuc970.crf ..\..\Driver\Source\system_nuc970.c]
                          ARM

                          AREA ||i._sysLockCode||, CODE, READONLY, ALIGN=2

                  _sysLockCode PROC
;;;397    
;;;398    INT32 _sysLockCode(UINT32 addr, INT32 size)
000000  ee192f30          MRC      p15,#0x0,r2,c9,c0,#1
;;;399    {
;;;400        int i, cnt, temp;
;;;401    
;;;402        __asm {
;;;403            /* use way3 to lock instructions */
;;;404            MRC p15, 0, temp, c9, c0, 1 ;
;;;405            ORR temp, temp, 0x07 ;
000004  e3822007          ORR      r2,r2,#7
;;;406            MCR p15, 0, temp, c9, c0, 1 ;
000008  ee092f30          MCR      p15,#0x0,r2,c9,c0,#1
;;;407        }
;;;408    
;;;409        if (size % 16)  cnt = (size/16) + 1;
00000c  e311000f          TST      r1,#0xf
000010  e1a02fc1          ASR      r2,r1,#31
000014  e0811e22          ADD      r1,r1,r2,LSR #28
000018  13a02001          MOVNE    r2,#1
00001c  10822241          ADDNE    r2,r2,r1,ASR #4
;;;410        else            cnt = size / 16;
000020  01a02241          ASREQ    r2,r1,#4
;;;411    
;;;412        for (i=0; i<cnt; i++) {
000024  e3a01000          MOV      r1,#0
                  |L1.40|
000028  e1510002          CMP      r1,r2
;;;413            __asm {
;;;414                MCR p15, 0, addr, c7, c13, 1;
00002c  be070f3d          MCRLT    p15,#0x0,r0,c7,c13,#1
000030  b2800010          ADDLT    r0,r0,#0x10
000034  b2811001          ADDLT    r1,r1,#1
;;;415            }
;;;416    
;;;417            addr += 16;
;;;418        }
;;;419    
;;;420    
;;;421        __asm {
;;;422            /* use way3 to lock instructions */
;;;423            MRC p15, 0, temp, c9, c0, 1 ;
000038  ae190f30          MRCGE    p15,#0x0,r0,c9,c0,#1
;;;424            BIC temp, temp, 0x07 ;
00003c  a3c00007          BICGE    r0,r0,#7
;;;425            ORR temp, temp, 0x08 ;
000040  a3800008          ORRGE    r0,r0,#8
;;;426            MCR p15, 0, temp, c9, c0, 1 ;
000044  ae090f30          MCRGE    p15,#0x0,r0,c9,c0,#1
;;;427        }
;;;428    
;;;429        return 0;
000048  a3a00000          MOVGE    r0,#0
00004c  bafffff5          BLT      |L1.40|
;;;430    
;;;431    }
000050  e12fff1e          BX       lr
;;;432    
                          ENDP


                          AREA ||i._sysUnLockCode||, CODE, READONLY, ALIGN=2

                  _sysUnLockCode PROC
;;;433    
;;;434    INT32 _sysUnLockCode()
000000  ee190f30          MRC      p15,#0x0,r0,c9,c0,#1
;;;435    {
;;;436        int temp;
;;;437    
;;;438        /* unlock I-cache way 3 */
;;;439        __asm {
;;;440            MRC p15, 0, temp, c9, c0, 1;
;;;441            BIC temp, temp, 0x08 ;
000004  e3c00008          BIC      r0,r0,#8
;;;442            MCR p15, 0, temp, c9, c0, 1;
000008  ee090f30          MCR      p15,#0x0,r0,c9,c0,#1
;;;443    
;;;444        }
;;;445    
;;;446        return 0;
00000c  e3a00000          MOV      r0,#0
;;;447    }
000010  e12fff1e          BX       lr
;;;448    
                          ENDP


                          AREA ||i.sysDisableCache||, CODE, READONLY, ALIGN=2

                  sysDisableCache PROC
;;;472     */
;;;473    void sysDisableCache(void)
000000  e92d4010          PUSH     {r4,lr}
;;;474    {
;;;475        int temp;
;;;476    
;;;477        sys_flush_and_clean_dcache();
000004  ebfffffe          BL       sys_flush_and_clean_dcache
;;;478        __asm {
;;;479            /*----- flush I, D cache & write buffer -----*/
;;;480            MOV temp, 0x0
000008  e3a00000          MOV      r0,#0
;;;481            MCR p15, 0, temp, c7, c5, 0 /* flush I cache */
00000c  ee070f15          MCR      p15,#0x0,r0,c7,c5,#0
;;;482            MCR p15, 0, temp, c7, c6, 0 /* flush D cache */
000010  ee070f16          MCR      p15,#0x0,r0,c7,c6,#0
;;;483            MCR p15, 0, temp, c7, c10,4 /* drain write buffer */
000014  ee070f9a          MCR      p15,#0x0,r0,c7,c10,#4
;;;484    
;;;485            /*----- disable Protection Unit -----*/
;;;486            MRC p15, 0, temp, c1, c0, 0     /* read Control register */
000018  ee110f10          MRC      p15,#0x0,r0,c1,c0,#0
;;;487            BIC temp, temp, 0x01
00001c  e3c00001          BIC      r0,r0,#1
;;;488            MCR p15, 0, temp, c1, c0, 0     /* write Control register */
000020  ee010f10          MCR      p15,#0x0,r0,c1,c0,#0
;;;489        }
;;;490        _sys_IsCacheOn = FALSE;
000024  e59f0010          LDR      r0,|L3.60|
000028  e3a01000          MOV      r1,#0
00002c  e5c01000          STRB     r1,[r0,#0]  ; _sys_IsCacheOn
;;;491        _sys_CacheMode = CACHE_DISABLE;
000030  e3e01000          MVN      r1,#0
000034  e5801008          STR      r1,[r0,#8]  ; _sys_CacheMode
;;;492    
;;;493    }
000038  e8bd8010          POP      {r4,pc}
;;;494    
                          ENDP

                  |L3.60|
                          DCD      ||.data||

                          AREA ||i.sysEnableCache||, CODE, READONLY, ALIGN=2

                  sysEnableCache PROC
;;;458     */
;;;459    INT32 sysEnableCache(UINT32 uCacheOpMode)
000000  e92d4010          PUSH     {r4,lr}
;;;460    {
000004  e1a04000          MOV      r4,r0
;;;461        sysInitMMUTable(uCacheOpMode);
000008  ebfffffe          BL       sysInitMMUTable
;;;462        _sys_IsCacheOn = TRUE;
00000c  e59f1010          LDR      r1,|L4.36|
000010  e3a02001          MOV      r2,#1
000014  e5c12000          STRB     r2,[r1,#0]  ; _sys_IsCacheOn
;;;463        _sys_CacheMode = uCacheOpMode;
000018  e5814008          STR      r4,[r1,#8]  ; _sys_CacheMode
;;;464    
;;;465        return 0;
00001c  e3a00000          MOV      r0,#0
;;;466    }
000020  e8bd8010          POP      {r4,pc}
;;;467    
                          ENDP

                  |L4.36|
                          DCD      ||.data||

                          AREA ||i.sysFlushCache||, CODE, READONLY, ALIGN=2

                  sysFlushCache PROC
;;;338    
;;;339    void sysFlushCache(INT32 nCacheType)
000000  e3500006          CMP      r0,#6
;;;340    {
000004  e92d4010          PUSH     {r4,lr}
;;;341        int temp;
;;;342    
;;;343        switch (nCacheType) {
;;;344        case I_CACHE:
;;;345            __asm {
;;;346                /*----- flush I-cache -----*/
;;;347                MOV temp, 0x0
000008  03a00000          MOVEQ    r0,#0
;;;348                MCR p15, 0, temp, c7, c5, 0 /* invalidate I cache */
00000c  0e070f15          MCREQ    p15,#0x0,r0,c7,c5,#0
;;;349            }
;;;350            break;
;;;351    
;;;352        case D_CACHE:
;;;353                sys_flush_and_clean_dcache();
;;;354            __asm {
;;;355                /*----- flush D-cache & write buffer -----*/
;;;356                MOV temp, 0x0
;;;357                MCR p15, 0, temp, c7, c10, 4 /* drain write buffer */
;;;358            }
;;;359            break;
;;;360    
;;;361        case I_D_CACHE:
;;;362                sys_flush_and_clean_dcache();
;;;363            __asm {
;;;364                /*----- flush I, D cache & write buffer -----*/
;;;365                MOV temp, 0x0
;;;366                MCR p15, 0, temp, c7, c5, 0 /* invalidate I cache */
;;;367                MCR p15, 0, temp, c7, c10, 4 /* drain write buffer */
;;;368            }
;;;369            break;
;;;370    
;;;371        default:
;;;372                ;
;;;373        }
;;;374    }
000010  08bd8010          POPEQ    {r4,pc}
000014  e3500007          CMP      r0,#7                 ;343
000018  0a000006          BEQ      |L5.56|
00001c  e3500008          CMP      r0,#8                 ;343
000020  18bd8010          POPNE    {r4,pc}
000024  ebfffffe          BL       sys_flush_and_clean_dcache
000028  e3a00000          MOV      r0,#0                 ;365
00002c  ee070f15          MCR      p15,#0x0,r0,c7,c5,#0  ;366
000030  ee070f9a          MCR      p15,#0x0,r0,c7,c10,#4 ;367
000034  e8bd8010          POP      {r4,pc}
                  |L5.56|
000038  ebfffffe          BL       sys_flush_and_clean_dcache
00003c  e3a00000          MOV      r0,#0                 ;356
000040  ee070f9a          MCR      p15,#0x0,r0,c7,c10,#4 ;357
000044  e8bd8010          POP      {r4,pc}
;;;375    
                          ENDP


                          AREA ||i.sysGetCacheMode||, CODE, READONLY, ALIGN=2

                  sysGetCacheMode PROC
;;;391    
;;;392    INT32 sysGetCacheMode()
000000  e59f0004          LDR      r0,|L6.12|
;;;393    {
;;;394        return _sys_CacheMode;
000004  e5900008          LDR      r0,[r0,#8]  ; _sys_CacheMode
;;;395    }
000008  e12fff1e          BX       lr
;;;396    
                          ENDP

                  |L6.12|
                          DCD      ||.data||

                          AREA ||i.sysGetCacheState||, CODE, READONLY, ALIGN=2

                  sysGetCacheState PROC
;;;385    
;;;386    BOOL sysGetCacheState()
000000  e59f0004          LDR      r0,|L7.12|
;;;387    {
;;;388        return _sys_IsCacheOn;
000004  e5d00000          LDRB     r0,[r0,#0]  ; _sys_IsCacheOn
;;;389    }
000008  e12fff1e          BX       lr
;;;390    
                          ENDP

                  |L7.12|
                          DCD      ||.data||

                          AREA ||i.sysGetPhyPageAddr||, CODE, READONLY, ALIGN=2

                  sysGetPhyPageAddr PROC
;;;39     
;;;40     unsigned int sysGetPhyPageAddr(unsigned int vaddr)
000000  e59f204c          LDR      r2,|L8.84|
;;;41     {
;;;42         int table_num, page_num;
;;;43         unsigned int base_addr, page_base, page_offset, phy_addr;
;;;44         volatile _CTable *PageTabPtr;
;;;45     
;;;46         if (vaddr & 0x80000000)
000004  e3100102          TST      r0,#0x80000000
000008  e5d22000          LDRB     r2,[r2,#0]  ; _sys_IsCacheOn
;;;47             PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
00000c  159f1038          LDRNE    r1,|L8.76|
;;;48         else
;;;49             PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
000010  059f1038          LDREQ    r1,|L8.80|
;;;50     
;;;51         if (sysGetCacheState() == TRUE)
000014  e3520001          CMP      r2,#1
;;;52             PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
;;;53     
;;;54         base_addr = vaddr & 0x7FFFF000;
;;;55         table_num = base_addr / 0x100000;
;;;56         page_num = (base_addr & 0xFF000) >> 12;
;;;57     
;;;58         page_base = (*(PageTabPtr+table_num)).page[page_num] & 0xFFFFF000;
;;;59         page_offset = vaddr & 0xFFF;
;;;60         phy_addr = page_base + page_offset;
;;;61     
;;;62         return phy_addr;
;;;63     
;;;64     } /* end sysGetPHYAddr */
000018  e59f2038          LDR      r2,|L8.88|
00001c  03811102          ORREQ    r1,r1,#0x80000000     ;52
000020  e0022a20          AND      r2,r2,r0,LSR #20
000024  e3a030ff          MOV      r3,#0xff
000028  e0033620          AND      r3,r3,r0,LSR #12
00002c  e0811502          ADD      r1,r1,r2,LSL #10      ;58
000030  e7911103          LDR      r1,[r1,r3,LSL #2]     ;58
000034  e1a00a00          LSL      r0,r0,#20             ;59
000038  e1a01621          LSR      r1,r1,#12             ;58
00003c  e1a01601          LSL      r1,r1,#12             ;58
000040  e1a00a20          LSR      r0,r0,#20             ;59
000044  e0800001          ADD      r0,r0,r1              ;60
000048  e12fff1e          BX       lr
;;;65     
                          ENDP

                  |L8.76|
                          DCD      ||.bss||+0x14000
                  |L8.80|
                          DCD      ||.bss||+0x4000
                  |L8.84|
                          DCD      ||.data||
                  |L8.88|
                          DCD      0x000007ff

                          AREA ||i.sysGetSdramSizebyMB||, CODE, READONLY, ALIGN=2

                  sysGetSdramSizebyMB PROC
;;;266    
;;;267    INT32 sysGetSdramSizebyMB()
000000  e92d400c          PUSH     {r2,r3,lr}
;;;268    {
;;;269        unsigned int volatile reg, totalsize=0;
000004  e3a00000          MOV      r0,#0
000008  e58d0000          STR      r0,[sp,#0]
;;;270    
;;;271        reg = inpw(SDIC_BA+0x10) & 0x07;
00000c  e59f010c          LDR      r0,|L9.288|
000010  e5900000          LDR      r0,[r0,#0]
000014  e2000007          AND      r0,r0,#7
;;;272        switch(reg) {
000018  e3500008          CMP      r0,#8
00001c  e58d0004          STR      r0,[sp,#4]            ;271
000020  308ff100          ADDCC    pc,pc,r0,LSL #2
000024  ea00000b          B        |L9.88|
000028  ea00000a          B        |L9.88|
00002c  ea000005          B        |L9.72|
000030  ea000006          B        |L9.80|
000034  ea000016          B        |L9.148|
000038  ea000017          B        |L9.156|
00003c  ea000018          B        |L9.164|
000040  ea000019          B        |L9.172|
000044  ea00001a          B        |L9.180|
                  |L9.72|
;;;273        case 1:
;;;274            totalsize += 2;
000048  e3a00002          MOV      r0,#2
;;;275            break;
00004c  ea000000          B        |L9.84|
                  |L9.80|
;;;276    
;;;277        case 2:
;;;278            totalsize += 4;
000050  e3a00004          MOV      r0,#4
                  |L9.84|
000054  e58d0000          STR      r0,[sp,#0]            ;274
                  |L9.88|
;;;279            break;
;;;280    
;;;281        case 3:
;;;282            totalsize += 8;
;;;283            break;
;;;284    
;;;285        case 4:
;;;286            totalsize += 16;
;;;287            break;
;;;288    
;;;289        case 5:
;;;290            totalsize += 32;
;;;291            break;
;;;292    
;;;293        case 6:
;;;294            totalsize += 64;
;;;295            break;
;;;296    
;;;297        case 7:
;;;298            totalsize += 128;
;;;299            break;
;;;300        }
;;;301    
;;;302        reg = inpw(SDIC_BA+0x14) & 0x07;
000058  e59f00c4          LDR      r0,|L9.292|
00005c  e5900000          LDR      r0,[r0,#0]
000060  e2000007          AND      r0,r0,#7
;;;303        switch(reg) {
000064  e3500008          CMP      r0,#8
000068  e58d0004          STR      r0,[sp,#4]            ;302
00006c  308ff100          ADDCC    pc,pc,r0,LSL #2
000070  ea000017          B        |L9.212|
000074  ea000016          B        |L9.212|
000078  ea00000f          B        |L9.188|
00007c  ea000011          B        |L9.200|
000080  ea000017          B        |L9.228|
000084  ea000019          B        |L9.240|
000088  ea00001b          B        |L9.252|
00008c  ea00001d          B        |L9.264|
000090  ea00001f          B        |L9.276|
                  |L9.148|
000094  e3a00008          MOV      r0,#8                 ;282
000098  eaffffed          B        |L9.84|
                  |L9.156|
00009c  e3a00010          MOV      r0,#0x10              ;286
0000a0  eaffffeb          B        |L9.84|
                  |L9.164|
0000a4  e3a00020          MOV      r0,#0x20              ;290
0000a8  eaffffe9          B        |L9.84|
                  |L9.172|
0000ac  e3a00040          MOV      r0,#0x40              ;294
0000b0  eaffffe7          B        |L9.84|
                  |L9.180|
0000b4  e3a00080          MOV      r0,#0x80              ;298
0000b8  eaffffe5          B        |L9.84|
                  |L9.188|
;;;304        case 1:
;;;305            totalsize += 2;
0000bc  e59d0000          LDR      r0,[sp,#0]
0000c0  e2800002          ADD      r0,r0,#2
;;;306            break;
0000c4  ea000001          B        |L9.208|
                  |L9.200|
;;;307    
;;;308        case 2:
;;;309            totalsize += 4;
0000c8  e59d0000          LDR      r0,[sp,#0]
0000cc  e2800004          ADD      r0,r0,#4
                  |L9.208|
0000d0  e58d0000          STR      r0,[sp,#0]            ;305
                  |L9.212|
;;;310            break;
;;;311    
;;;312        case 3:
;;;313            totalsize += 8;
;;;314            break;
;;;315    
;;;316        case 4:
;;;317            totalsize += 16;
;;;318            break;
;;;319    
;;;320        case 5:
;;;321            totalsize += 32;
;;;322            break;
;;;323    
;;;324        case 6:
;;;325            totalsize += 64;
;;;326            break;
;;;327    
;;;328        case 7:
;;;329            totalsize += 128;
;;;330            break;
;;;331        }
;;;332    
;;;333        if (totalsize != 0)
0000d4  e59d0000          LDR      r0,[sp,#0]
0000d8  e3500000          CMP      r0,#0
;;;334            return totalsize;
;;;335        else
;;;336            return 1;
0000dc  03a00001          MOVEQ    r0,#1
;;;337    }
0000e0  e8bd800c          POP      {r2,r3,pc}
                  |L9.228|
0000e4  e59d0000          LDR      r0,[sp,#0]            ;313
0000e8  e2800008          ADD      r0,r0,#8              ;313
0000ec  eafffff7          B        |L9.208|
                  |L9.240|
0000f0  e59d0000          LDR      r0,[sp,#0]            ;317
0000f4  e2800010          ADD      r0,r0,#0x10           ;317
0000f8  eafffff4          B        |L9.208|
                  |L9.252|
0000fc  e59d0000          LDR      r0,[sp,#0]            ;321
000100  e2800020          ADD      r0,r0,#0x20           ;321
000104  eafffff1          B        |L9.208|
                  |L9.264|
000108  e59d0000          LDR      r0,[sp,#0]            ;325
00010c  e2800040          ADD      r0,r0,#0x40           ;325
000110  eaffffee          B        |L9.208|
                  |L9.276|
000114  e59d0000          LDR      r0,[sp,#0]            ;329
000118  e2800080          ADD      r0,r0,#0x80           ;329
00011c  eaffffeb          B        |L9.208|
;;;338    
                          ENDP

                  |L9.288|
                          DCD      0xb0001810
                  |L9.292|
                          DCD      0xb0001814

                          AREA ||i.sysInitMMUTable||, CODE, READONLY, ALIGN=2

                  sysInitMMUTable PROC
;;;184    
;;;185    int sysInitMMUTable(int cache_mode)
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;186    {
;;;187        unsigned volatile int temp;
;;;188        int i, size, ramsize;
;;;189    
;;;190        if (_IsInitMMUTable == FALSE) {
000004  e59f917c          LDR      r9,|L10.392|
000008  e24dd008          SUB      sp,sp,#8              ;186
00000c  e5d90001          LDRB     r0,[r9,#1]  ; _IsInitMMUTable
000010  e3500000          CMP      r0,#0
000014  0a000003          BEQ      |L10.40|
                  |L10.24|
;;;191            ramsize = sysGetSdramSizebyMB();
;;;192    
;;;193            //flat mapping for 4GB, 4096 section table, each size is 1MB
;;;194            temp = 0xC00;   /* (11:10) access permission, R/W */
;;;195            temp |= 0x1E0;  /* (8:5) domain 15 */
;;;196            temp |= 0x10;   /* bit 4 must be 1 */
;;;197            temp |= 0x00;   /* bit 3:2 for cache control bits, cache disabled */
;;;198            temp |= 0x02;   /* set as 1Mb section */
;;;199    
;;;200            for (i=0; i<4096; i++) {
;;;201                _mmuSectionTable[i] = (unsigned int)(temp | (i << 20));
;;;202            }
;;;203    
;;;204            //Inside SDRAM, divide each section into 256 small pages, each page size is 4KB
;;;205            if (ramsize > _CoarsePageSize) size = _CoarsePageSize;  //maximum 64MB
;;;206            else                           size = ramsize;
;;;207    
;;;208            /* first 1M always direct mapping */
;;;209            sysInitPageTable(0, 0, 0x100000, cache_mode, MMU_DIRECT_MAPPING);
;;;210            temp = ((unsigned int)_mmuCoarsePageTable  & 0xFFFFFC00); /*  coarse table base address */
;;;211            temp |= 0x1E0;  /* (8:5) domain 15 */
;;;212            temp |= 0x10;   /* bit 4 must be 1 */
;;;213            temp |= 0x01;   /* Coarse page table */
;;;214            _mmuSectionTable[0] = temp;
;;;215    
;;;216            /* Create a shadow area at 0x80000000 for non-cacheable region */
;;;217            sysInitPageTable(0x80000000, 0x0, 0x100000, CACHE_DISABLE, MMU_DIRECT_MAPPING);
;;;218            temp = ((unsigned int)_mmuCoarsePageTable_NonCache  & 0xFFFFFC00); /*  coarse table base address */
;;;219            temp |= 0x1E0;  /* (8:5) domain 15 */
;;;220            temp |= 0x10;   /* bit 4 must be 1 */
;;;221            temp |= 0x01;   /* Coarse page table */
;;;222            _mmuSectionTable[0x800] = temp;
;;;223    
;;;224            /* Mapping the other memory */
;;;225            for (i=1; i< size; i++) {
;;;226                temp = (((unsigned int)_mmuCoarsePageTable + (unsigned int)i*1024) & 0xFFFFFC00); /*  coarse table base address */
;;;227                //temp = ((unsigned int)(0x604000 + i*1024) & 0xFFFFFC00); /* coarse table base address */
;;;228                temp |= 0x1E0;  /* (8:5) domain 15 */
;;;229                temp |= 0x10;   /* bit 4 must be 1 */
;;;230                temp |= 0x01;   /* Coarse page table */
;;;231    
;;;232                if (_MMUMappingMode == MMU_DIRECT_MAPPING)
;;;233                    sysInitPageTable((i << 20), (i << 20), 0x100000, cache_mode, MMU_DIRECT_MAPPING); /* direct mapping */
;;;234                else
;;;235                    sysInitPageTable((i << 20), (i << 20), 0x100000, cache_mode, MMU_INVERSE_MAPPING); /* inverse mapping for each 1MB area */
;;;236    
;;;237                _mmuSectionTable[i] = temp;
;;;238            }
;;;239    
;;;240            //Create shadow non-cacheabel region
;;;241            for (i=1; i< size; i++) {
;;;242                temp = (((unsigned int)_mmuCoarsePageTable_NonCache + (unsigned int)i*1024) & 0xFFFFFC00); /*  coarse table base address */
;;;243                //temp = ((unsigned int)(0x604000 + i*1024) & 0xFFFFFC00); /* coarse table base address */
;;;244                temp |= 0x1E0;  /* (8:5) domain 15 */
;;;245                temp |= 0x10;   /* bit 4 must be 1 */
;;;246                temp |= 0x01;   /* Coarse page table */
;;;247    
;;;248                if (_MMUMappingMode == MMU_DIRECT_MAPPING)
;;;249                    sysInitPageTable(((i << 20) | 0x80000000), (i << 20), 0x100000, CACHE_DISABLE, MMU_DIRECT_MAPPING); /* direct mapping */
;;;250                else
;;;251                    sysInitPageTable(((i << 20) | 0x80000000), (i << 20), 0x100000, CACHE_DISABLE, MMU_INVERSE_MAPPING); /* inverse mapping for each 1MB area */
;;;252    
;;;253                _mmuSectionTable[0x800+i] = temp;
;;;254            }
;;;255    
;;;256            _IsInitMMUTable = TRUE;
;;;257        }
;;;258    
;;;259        //moved here by cmn [2007/01/27]
;;;260        //set CP15 registers
;;;261        sysSetupCP15((unsigned int)_mmuSectionTable);
000018  e59f016c          LDR      r0,|L10.396|
00001c  ebfffffe          BL       sysSetupCP15
;;;262    
;;;263        return 0;
000020  e3a00000          MOV      r0,#0
;;;264    
;;;265    } /* end sysInitMMUTable */
000024  e8bd8ffe          POP      {r1-r11,pc}
                  |L10.40|
000028  ebfffffe          BL       sysGetSdramSizebyMB
00002c  e59f115c          LDR      r1,|L10.400|
000030  e59f6154          LDR      r6,|L10.396|
000034  e58d1004          STR      r1,[sp,#4]            ;198
000038  e3a01000          MOV      r1,#0                 ;200
                  |L10.60|
00003c  e59d2004          LDR      r2,[sp,#4]            ;201
000040  e1822a01          ORR      r2,r2,r1,LSL #20      ;201
000044  e7862101          STR      r2,[r6,r1,LSL #2]     ;201
000048  e2811001          ADD      r1,r1,#1              ;201
00004c  e3510a01          CMP      r1,#0x1000            ;200
000050  bafffff9          BLT      |L10.60|
000054  e3500040          CMP      r0,#0x40              ;205
000058  e3a07000          MOV      r7,#0                 ;209
00005c  d1a05000          MOVLE    r5,r0                 ;206
000060  e59d3008          LDR      r3,[sp,#8]            ;209
000064  c3a05040          MOVGT    r5,#0x40              ;205
000068  e3a02601          MOV      r2,#0x100000          ;209
00006c  e1a01007          MOV      r1,r7                 ;209
000070  e1a00007          MOV      r0,r7                 ;209
000074  e58d7000          STR      r7,[sp,#0]            ;209
000078  ebfffffe          BL       sysInitPageTable
00007c  e59fb110          LDR      r11,|L10.404|
000080  e3e03000          MVN      r3,#0                 ;217
000084  e38b0e1e          ORR      r0,r11,#0x1e0         ;211
000088  e3800010          ORR      r0,r0,#0x10           ;212
00008c  e3800001          ORR      r0,r0,#1              ;213
000090  e58d0004          STR      r0,[sp,#4]            ;214
000094  e5860000          STR      r0,[r6,#0]            ;217  ; _mmuSectionTable
000098  e3a02601          MOV      r2,#0x100000          ;217
00009c  e3a01000          MOV      r1,#0                 ;217
0000a0  e3a00102          MOV      r0,#0x80000000        ;217
0000a4  e58d7000          STR      r7,[sp,#0]            ;217
0000a8  ebfffffe          BL       sysInitPageTable
0000ac  e28ba801          ADD      r10,r11,#0x10000      ;218
0000b0  e38a0e1e          ORR      r0,r10,#0x1e0         ;219
0000b4  e3800010          ORR      r0,r0,#0x10           ;220
0000b8  e3800001          ORR      r0,r0,#1              ;221
0000bc  e1a01000          MOV      r1,r0                 ;222
0000c0  e58d0004          STR      r0,[sp,#4]            ;221
0000c4  e24b0a02          SUB      r0,r11,#0x2000        ;222
0000c8  e3a04001          MOV      r4,#1                 ;225
0000cc  e1a08004          MOV      r8,r4                 ;225
0000d0  e5801000          STR      r1,[r0,#0]            ;225  ; _mmuSectionTable
                  |L10.212|
0000d4  e1540005          CMP      r4,r5                 ;225
0000d8  a3a04001          MOVGE    r4,#1                 ;241
0000dc  a3a0b102          MOVGE    r11,#0x80000000       ;217
0000e0  aa000024          BGE      |L10.376|
0000e4  e08b0504          ADD      r0,r11,r4,LSL #10     ;226
0000e8  e3800e1e          ORR      r0,r0,#0x1e0          ;228
0000ec  e3800010          ORR      r0,r0,#0x10           ;229
0000f0  e3800001          ORR      r0,r0,#1              ;230
0000f4  e58d0004          STR      r0,[sp,#4]            ;232
0000f8  e5990004          LDR      r0,[r9,#4]            ;232  ; _MMUMappingMode
0000fc  e59d3008          LDR      r3,[sp,#8]            ;235
000100  e3500000          CMP      r0,#0                 ;232
000104  e1a00a04          LSL      r0,r4,#20             ;235
000108  058d7000          STREQ    r7,[sp,#0]            ;233
00010c  e3a02601          MOV      r2,#0x100000          ;235
000110  e1a01000          MOV      r1,r0                 ;235
000114  158d8000          STRNE    r8,[sp,#0]            ;235
000118  ebfffffe          BL       sysInitPageTable
00011c  e59d0004          LDR      r0,[sp,#4]            ;237
000120  e7860104          STR      r0,[r6,r4,LSL #2]     ;237
000124  e2844001          ADD      r4,r4,#1              ;237
000128  eaffffe9          B        |L10.212|
                  |L10.300|
00012c  e08a0504          ADD      r0,r10,r4,LSL #10     ;242
000130  e3800e1e          ORR      r0,r0,#0x1e0          ;244
000134  e3800010          ORR      r0,r0,#0x10           ;245
000138  e3800001          ORR      r0,r0,#1              ;246
00013c  e58d0004          STR      r0,[sp,#4]            ;248
000140  e5990004          LDR      r0,[r9,#4]            ;248  ; _MMUMappingMode
000144  e1a01a04          LSL      r1,r4,#20             ;251
000148  e3500000          CMP      r0,#0                 ;248
00014c  058d7000          STREQ    r7,[sp,#0]            ;249
000150  e18b0a04          ORR      r0,r11,r4,LSL #20     ;251
000154  e3e03000          MVN      r3,#0                 ;251
000158  e3a02601          MOV      r2,#0x100000          ;251
00015c  158d8000          STRNE    r8,[sp,#0]            ;251
000160  ebfffffe          BL       sysInitPageTable
000164  e0860104          ADD      r0,r6,r4,LSL #2       ;253
000168  e59d1004          LDR      r1,[sp,#4]            ;253
00016c  e2800a02          ADD      r0,r0,#0x2000         ;253
000170  e2844001          ADD      r4,r4,#1              ;253
000174  e5801000          STR      r1,[r0,#0]            ;253
                  |L10.376|
000178  e1540005          CMP      r4,r5                 ;241
00017c  a5c98001          STRBGE   r8,[r9,#1]            ;256  ; _IsInitMMUTable
000180  baffffe9          BLT      |L10.300|
000184  eaffffa3          B        |L10.24|
;;;266    
                          ENDP

                  |L10.392|
                          DCD      ||.data||
                  |L10.396|
                          DCD      ||.bss||
                  |L10.400|
                          DCD      0x00000df2
                  |L10.404|
                          DCD      ||.bss||+0x4000

                          AREA ||i.sysInitPageTable||, CODE, READONLY, ALIGN=2

                  sysInitPageTable PROC
;;;115    
;;;116    int sysInitPageTable(unsigned int vaddr, unsigned int phy_addr, int size, int cache_flag, int rev_flag)
000000  e92d43fc          PUSH     {r2-r9,lr}
;;;117    {
000004  e59f40dc          LDR      r4,|L11.232|
;;;118        int i, cnt, table_num, page_num, cache_mode, addr_offset;
;;;119        unsigned volatile int phy_base_addr, vbase_addr, temp;
;;;120        volatile _CTable *PageTabPtr;
;;;121    
;;;122        if (vaddr & 0x80000000)
000008  e3100102          TST      r0,#0x80000000
00000c  e5d44000          LDRB     r4,[r4,#0]  ; _sys_IsCacheOn
000010  e59d6024          LDR      r6,[sp,#0x24]
;;;123            PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
000014  159fc0c4          LDRNE    r12,|L11.224|
;;;124        else
;;;125            PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
000018  059fc0c4          LDREQ    r12,|L11.228|
;;;126    
;;;127        if (sysGetCacheState() == TRUE)
00001c  e3540001          CMP      r4,#1
;;;128            PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
;;;129    
;;;130        //if ( _IsInitMMUTable == FALSE ) return -1;
;;;131        vaddr &= 0x7FFFFFFF;    //ignore the non-cacheable bit 31
000020  e3c04102          BIC      r4,r0,#0x80000000
000024  038cc102          ORREQ    r12,r12,#0x80000000   ;128
;;;132        if ((vaddr + size) > (_CoarsePageSize << 20)) return -1;
000028  e0840002          ADD      r0,r4,r2
00002c  e3500301          CMP      r0,#0x4000000
;;;133        if (vaddr & 0xFFFFF)    return -1;  /* MUST 1M Boundary */
000030  91b00604          LSLSLS   r0,r4,#12
;;;134        if (size % 4096)        return -1;  /* MUST 4K multiple size */
000034  01b00a02          LSLSEQ   r0,r2,#20
000038  13e00000          MVNNE    r0,#0
00003c  1a000026          BNE      |L11.220|
;;;135    
;;;136        /* Pages count */
;;;137        cnt = size / 4096;
000040  e1a00fc2          ASR      r0,r2,#31
;;;138    
;;;139        if (cache_flag == CACHE_WRITE_BACK) /* write back mode */
000044  e3530000          CMP      r3,#0
000048  e0820a20          ADD      r0,r2,r0,LSR #20      ;137
00004c  e1a07640          ASR      r7,r0,#12             ;137
;;;140            cache_mode = 0x0C;
000050  03a0300c          MOVEQ    r3,#0xc
000054  0a000002          BEQ      |L11.100|
;;;141        else if (cache_flag == CACHE_WRITE_THROUGH) /* write through mode */
000058  e3530001          CMP      r3,#1
;;;142            cache_mode = 0x08;
00005c  03a03008          MOVEQ    r3,#8
;;;143        else
;;;144            cache_mode = 0; /* Non-cacheable, non-buffered */
000060  13a03000          MOVNE    r3,#0
                  |L11.100|
;;;145    
;;;146    
;;;147        if (rev_flag == MMU_DIRECT_MAPPING)
000064  e3560000          CMP      r6,#0
;;;148            phy_base_addr = phy_addr;
;;;149        else
;;;150            phy_base_addr = phy_addr + size - 4096;
000068  10810002          ADDNE    r0,r1,r2
00006c  058d1004          STREQ    r1,[sp,#4]            ;148
000070  12400a01          SUBNE    r0,r0,#0x1000
000074  158d0004          STRNE    r0,[sp,#4]
;;;151    
;;;152        addr_offset = 4096;
000078  e3a01a01          MOV      r1,#0x1000
;;;153        for (i=0; i<cnt; i++) {
00007c  e3a00000          MOV      r0,#0
;;;154            vbase_addr = vaddr + i * 4096;
;;;155            table_num = vbase_addr / 0x100000;
;;;156            page_num =  (vbase_addr & 0xFF000) >> 12; /* bits [19:12] for level two table index */
;;;157    
;;;158            temp = phy_base_addr & 0xFFFFF000;
;;;159            temp |= 0xFF0; /* access permission, 11 for read/write */
;;;160            temp |= cache_mode; /* cache mode */
;;;161            temp |= 0x02;  /* small page */
;;;162    
;;;163            (*(PageTabPtr+table_num)).page[page_num] = temp;
;;;164    
;;;165            if (rev_flag == MMU_DIRECT_MAPPING)
;;;166                phy_base_addr += addr_offset;
;;;167            else
;;;168                phy_base_addr -= addr_offset;
;;;169        }
;;;170    
;;;171        return 0;
;;;172    
;;;173    } /* end sysInitPageTable */
000080  e3a080ff          MOV      r8,#0xff
                  |L11.132|
000084  e1500007          CMP      r0,r7                 ;153
000088  a3a00000          MOVGE    r0,#0                 ;171
00008c  aa000012          BGE      |L11.220|
000090  e59d9004          LDR      r9,[sp,#4]            ;158
000094  e0842600          ADD      r2,r4,r0,LSL #12      ;154
000098  e1a09629          LSR      r9,r9,#12             ;158
00009c  e1a09609          LSL      r9,r9,#12             ;158
0000a0  e3899eff          ORR      r9,r9,#0xff0          ;159
0000a4  e1a05a22          LSR      r5,r2,#20             ;155
0000a8  e1899003          ORR      r9,r9,r3              ;160
0000ac  e3899002          ORR      r9,r9,#2              ;161
0000b0  e0082622          AND      r2,r8,r2,LSR #12
0000b4  e08c5505          ADD      r5,r12,r5,LSL #10     ;163
0000b8  e58d9000          STR      r9,[sp,#0]            ;163
0000bc  e7859102          STR      r9,[r5,r2,LSL #2]     ;163
0000c0  e59d2004          LDR      r2,[sp,#4]            ;168
0000c4  e3560000          CMP      r6,#0                 ;165
0000c8  00822001          ADDEQ    r2,r2,r1              ;166
0000cc  10422001          SUBNE    r2,r2,r1              ;168
0000d0  e2800001          ADD      r0,r0,#1              ;168
0000d4  e58d2004          STR      r2,[sp,#4]            ;168
0000d8  eaffffe9          B        |L11.132|
                  |L11.220|
0000dc  e8bd83fc          POP      {r2-r9,pc}
;;;174    
                          ENDP

                  |L11.224|
                          DCD      ||.bss||+0x14000
                  |L11.228|
                          DCD      ||.bss||+0x4000
                  |L11.232|
                          DCD      ||.data||

                          AREA ||i.sysInvalidCache||, CODE, READONLY, ALIGN=2

                  sysInvalidCache PROC
;;;375    
;;;376    void sysInvalidCache()
000000  e3a00000          MOV      r0,#0
;;;377    {
;;;378        int temp;
;;;379    
;;;380        __asm {
;;;381            MOV temp, 0x0
;;;382            MCR p15, 0, temp, c7, c7, 0 /* invalidate I and D cache */
000004  ee070f17          MCR      p15,#0x0,r0,c7,c7,#0
;;;383        }
;;;384    }
000008  e12fff1e          BX       lr
;;;385    
                          ENDP


                          AREA ||i.sysSetCachePages||, CODE, READONLY, ALIGN=2

                  sysSetCachePages PROC
;;;66     
;;;67     int sysSetCachePages(unsigned int vaddr, int size, int cache_flag)
000000  e92d40f8          PUSH     {r3-r7,lr}
;;;68     {
000004  e59fc0a4          LDR      r12,|L13.176|
;;;69         int i, cnt, table_num, page_num, cache_mode;
;;;70         unsigned volatile int baseaddr, temp;
;;;71         volatile _CTable *PageTabPtr;
;;;72     
;;;73         if (vaddr & 0x80000000)
000008  e3100102          TST      r0,#0x80000000
00000c  e5dcc000          LDRB     r12,[r12,#0]  ; _sys_IsCacheOn
;;;74             PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
000010  159f3090          LDRNE    r3,|L13.168|
;;;75         else
;;;76             PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
000014  059f3090          LDREQ    r3,|L13.172|
;;;77     
;;;78         if (sysGetCacheState() == TRUE)
000018  e35c0001          CMP      r12,#1
;;;79             PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
;;;80     
;;;81         vaddr &= 0x7FFFFFFF;    //ignore the non-cacheable bit 31
00001c  e3c0c102          BIC      r12,r0,#0x80000000
000020  03833102          ORREQ    r3,r3,#0x80000000     ;79
;;;82         //if ( _IsInitMMUTable == FALSE ) return -1;
;;;83         if ((vaddr + size) > (_CoarsePageSize << 20)) return -1;
000024  e08c0001          ADD      r0,r12,r1
000028  e3500301          CMP      r0,#0x4000000
;;;84     
;;;85         if (vaddr & 0xFFF)  return -1;  /* MUST 4K Boundary */
00002c  91b00a0c          LSLSLS   r0,r12,#20
;;;86         if (size % 4096)    return -1;  /* MUST 4K multiple size */
000030  01b00a01          LSLSEQ   r0,r1,#20
000034  13e00000          MVNNE    r0,#0
000038  1a000019          BNE      |L13.164|
;;;87     
;;;88         /* for flat mapping address */
;;;89         cnt = size / 4096;
00003c  e1a00fc1          ASR      r0,r1,#31
;;;90     
;;;91         if (cache_flag == CACHE_WRITE_BACK) /* write back mode */
000040  e3520000          CMP      r2,#0
000044  e0810a20          ADD      r0,r1,r0,LSR #20      ;89
000048  e1a05640          ASR      r5,r0,#12             ;89
;;;92             cache_mode = 0x0C;
00004c  03a0400c          MOVEQ    r4,#0xc
000050  0a000002          BEQ      |L13.96|
;;;93         else if (cache_flag == CACHE_WRITE_THROUGH) /* write through mode */
000054  e3520001          CMP      r2,#1
;;;94             cache_mode = 0x08;
000058  03a04008          MOVEQ    r4,#8
;;;95         else
;;;96             cache_mode = 0; /* Non-cacheable, non-buffered */
00005c  13a04000          MOVNE    r4,#0
                  |L13.96|
;;;97     
;;;98         for (i=0; i<cnt; i++) {
000060  e3a00000          MOV      r0,#0
;;;99             baseaddr = vaddr + i * 4096;
;;;100            table_num = baseaddr / 0x100000;
;;;101            page_num =  (baseaddr & 0xFF000) >> 12; /* bits [19:12] for level two table index */
;;;102    
;;;103            temp = (*(PageTabPtr+table_num)).page[page_num] & 0xFFFFFFF3;
;;;104            temp |= cache_mode; /* cache mode */
;;;105            (*(PageTabPtr+table_num)).page[page_num] = temp;
;;;106        }
;;;107    
;;;108        //sysFlushCache(D_CACHE);
;;;109    
;;;110        return 0;
;;;111    
;;;112    } /* end sysSetCachePages */
000064  e3a060ff          MOV      r6,#0xff
000068  ea00000a          B        |L13.152|
                  |L13.108|
00006c  e08c1600          ADD      r1,r12,r0,LSL #12     ;99
000070  e1a02a21          LSR      r2,r1,#20             ;100
000074  e58d1000          STR      r1,[sp,#0]            ;99
000078  e0061621          AND      r1,r6,r1,LSR #12
00007c  e0832502          ADD      r2,r3,r2,LSL #10      ;103
000080  e7927101          LDR      r7,[r2,r1,LSL #2]     ;103
000084  e3c7700c          BIC      r7,r7,#0xc            ;103
000088  e1877004          ORR      r7,r7,r4              ;104
00008c  e58d7000          STR      r7,[sp,#0]            ;104
000090  e7827101          STR      r7,[r2,r1,LSL #2]     ;105
000094  e2800001          ADD      r0,r0,#1              ;105
                  |L13.152|
000098  e1500005          CMP      r0,r5                 ;98
00009c  a3a00000          MOVGE    r0,#0                 ;110
0000a0  bafffff1          BLT      |L13.108|
                  |L13.164|
0000a4  e8bd80f8          POP      {r3-r7,pc}
;;;113    
                          ENDP

                  |L13.168|
                          DCD      ||.bss||+0x14000
                  |L13.172|
                          DCD      ||.bss||+0x4000
                  |L13.176|
                          DCD      ||.data||

                          AREA ||i.sysSetMMUMappingMethod||, CODE, READONLY, ALIGN=2

                  sysSetMMUMappingMethod PROC
;;;175    
;;;176    int sysSetMMUMappingMethod(int mode)
000000  e59f1008          LDR      r1,|L14.16|
;;;177    {
;;;178        _MMUMappingMode = mode;
000004  e5810004          STR      r0,[r1,#4]  ; _MMUMappingMode
;;;179    
;;;180        return 0;
000008  e3a00000          MOV      r0,#0
;;;181    
;;;182    } /* end sysSetMMUMappingMethod */
00000c  e12fff1e          BX       lr
;;;183    
                          ENDP

                  |L14.16|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=14

                  _mmuSectionTable
                          %        16384
                  _mmuCoarsePageTable
                          %        65536
                  _mmuCoarsePageTable_NonCache
                          %        65536

                          AREA ||.data||, DATA, ALIGN=2

                  _sys_IsCacheOn
000000  00                DCB      0x00
                  _IsInitMMUTable
000001  000000            DCB      0x00,0x00,0x00
                  _MMUMappingMode
                          DCD      0x00000000
                  _sys_CacheMode
                          DCD      0x00000000
