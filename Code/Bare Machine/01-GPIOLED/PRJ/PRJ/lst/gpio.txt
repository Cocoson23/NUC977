; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\gpio.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\gpio.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931 -I..\..\Driver\Include -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\Toshiba -D__UVISION_VERSION=524 --omf_browse=.\obj\gpio.crf ..\..\Driver\Source\gpio.c]
                          ARM

                          AREA ||i.GPIO_BitIsUsed||, CODE, READONLY, ALIGN=2

                  GPIO_BitIsUsed PROC
;;;622    */
;;;623    BOOL GPIO_BitIsUsed(GPIO_PORT port, UINT32 bit)
000000  e59f2014          LDR      r2,|L1.28|
;;;624    {
;;;625        UINT32 mask;
;;;626        INT32 portIndex;
;;;627    
;;;628        portIndex = (port / 0x40);
000004  e1a00320          LSR      r0,r0,#6
;;;629        mask = (UINT32)bit;
;;;630    
;;;631        return ((gpioCfg.bitBusyFlag[portIndex] & mask)?TRUE:FALSE);
000008  e0820080          ADD      r0,r2,r0,LSL #1
00000c  e1d000b0          LDRH     r0,[r0,#0]
000010  e0100001          ANDS     r0,r0,r1
000014  13a00001          MOVNE    r0,#1
;;;632    }
000018  e12fff1e          BX       lr
;;;633    
                          ENDP

                  |L1.28|
                          DCD      ||.bss||

                          AREA ||i.GPIO_Close||, CODE, READONLY, ALIGN=2

                  GPIO_Close PROC
;;;244     */
;;;245    INT32 GPIO_Close(GPIO_PORT port)
000000  e59f3020          LDR      r3,|L2.40|
;;;246    {
;;;247        INT32 offset;
;;;248        INT32 portIndex;
;;;249    
;;;250        offset = (INT32)port;
;;;251        portIndex = (port / 0x40);
000004  e1a02320          LSR      r2,r0,#6
;;;252    
;;;253        /* Clean the busy flag */
;;;254        gpioCfg.bitBusyFlag[portIndex] = 0;
000008  e3a01000          MOV      r1,#0
00000c  e0832082          ADD      r2,r3,r2,LSL #1
000010  e1c210b0          STRH     r1,[r2,#0]
;;;255    
;;;256        /* Reset to input */
;;;257        outpw(REG_GPIOA_DIR + offset, 0);
000014  e59f2010          LDR      r2,|L2.44|
000018  e7a01002          STR      r1,[r0,r2]!
;;;258    
;;;259        /* Reset to pull-up */
;;;260        outpw(REG_GPIOA_PUEN + offset, 0);
00001c  e5801020          STR      r1,[r0,#0x20]
;;;261    
;;;262        return SUCCESSFUL;
000020  e1a00001          MOV      r0,r1
;;;263    }
000024  e12fff1e          BX       lr
;;;264    
                          ENDP

                  |L2.40|
                          DCD      ||.bss||
                  |L2.44|
                          DCD      0xb8003000

                          AREA ||i.GPIO_CloseBit||, CODE, READONLY, ALIGN=2

                  GPIO_CloseBit PROC
;;;431    */
;;;432    INT32 GPIO_CloseBit(GPIO_PORT port, UINT32 bit)
000000  e59f3034          LDR      r3,|L3.60|
;;;433    {
;;;434        UINT32 reg;
;;;435        UINT32 mask;
;;;436        INT32 portIndex;
;;;437        INT32 offset;
;;;438    
;;;439        offset = (INT32)port;
;;;440        portIndex = (port / 0x40);
000004  e1a02320          LSR      r2,r0,#6
;;;441        mask = (UINT32)bit;
;;;442    
;;;443        gpioCfg.bitBusyFlag[portIndex] = gpioCfg.bitBusyFlag[portIndex] & (~mask);
000008  e0832082          ADD      r2,r3,r2,LSL #1
00000c  e1d230b0          LDRH     r3,[r2,#0]
000010  e1c33001          BIC      r3,r3,r1
000014  e1c230b0          STRH     r3,[r2,#0]
;;;444    
;;;445        reg = inpw(REG_GPIOA_DIR + offset);
000018  e59f2020          LDR      r2,|L3.64|
00001c  e7b02002          LDR      r2,[r0,r2]!
;;;446        reg = reg & (~mask);
000020  e1c22001          BIC      r2,r2,r1
;;;447        outpw(REG_GPIOA_DIR + offset, reg);
000024  e5802000          STR      r2,[r0,#0]
;;;448    
;;;449        reg = inpw(REG_GPIOA_PUEN + offset);
000028  e5902020          LDR      r2,[r0,#0x20]
;;;450        reg = reg & (~mask);
00002c  e1c21001          BIC      r1,r2,r1
;;;451        outpw(REG_GPIOA_PUEN + offset, reg);
000030  e5801020          STR      r1,[r0,#0x20]
;;;452    
;;;453        return SUCCESSFUL;
000034  e3a00000          MOV      r0,#0
;;;454    }
000038  e12fff1e          BX       lr
;;;455    
                          ENDP

                  |L3.60|
                          DCD      ||.bss||
                  |L3.64|
                          DCD      0xb8003000

                          AREA ||i.GPIO_Clr||, CODE, READONLY, ALIGN=2

                  GPIO_Clr PROC
;;;300    */
;;;301    INT32 GPIO_Clr(GPIO_PORT port, UINT32 bitMap)
000000  e59f2014          LDR      r2,|L4.28|
;;;302    {
;;;303        INT32 offset;
;;;304        INT32 reg;
;;;305    
;;;306        offset = (INT32)port;
;;;307    
;;;308        reg = inpw(REG_GPIOA_DATAOUT + offset);
000004  e0800002          ADD      r0,r0,r2
000008  e5902004          LDR      r2,[r0,#4]
;;;309        reg = reg & (~bitMap);
00000c  e1c21001          BIC      r1,r2,r1
;;;310        outpw(REG_GPIOA_DATAOUT + offset, reg);
000010  e5801004          STR      r1,[r0,#4]
;;;311    
;;;312        return SUCCESSFUL;
000014  e3a00000          MOV      r0,#0
;;;313    }
000018  e12fff1e          BX       lr
;;;314    
                          ENDP

                  |L4.28|
                          DCD      0xb8003000

                          AREA ||i.GPIO_ClrBit||, CODE, READONLY, ALIGN=2

                  GPIO_ClrBit PROC
;;;540    */
;;;541    INT32 GPIO_ClrBit(GPIO_PORT port, UINT32 bit)
000000  e59f2014          LDR      r2,|L5.28|
;;;542    {
;;;543        UINT32 bitMap;
;;;544        INT32 offset;
;;;545        INT32 reg;
;;;546    
;;;547        offset = (INT32)port;
;;;548        bitMap = (UINT32)bit;
;;;549    
;;;550        reg = inpw(REG_GPIOA_DATAOUT + offset);
000004  e0800002          ADD      r0,r0,r2
000008  e5902004          LDR      r2,[r0,#4]
;;;551        reg = reg & (~bitMap);
00000c  e1c21001          BIC      r1,r2,r1
;;;552        outpw(REG_GPIOA_DATAOUT + offset, reg);
000010  e5801004          STR      r1,[r0,#4]
;;;553    
;;;554        return SUCCESSFUL;
000014  e3a00000          MOV      r0,#0
;;;555    }
000018  e12fff1e          BX       lr
;;;556    
                          ENDP

                  |L5.28|
                          DCD      0xb8003000

                          AREA ||i.GPIO_ClrISR||, CODE, READONLY, ALIGN=2

                  GPIO_ClrISR PROC
;;;494    */
;;;495    INT32 GPIO_ClrISR(GPIO_PORT port, UINT32 bitMap)
000000  e59f200c          LDR      r2,|L6.20|
;;;496    {
;;;497        INT32 offset;
;;;498    
;;;499        offset = (INT32)port;
;;;500    
;;;501        outpw(REG_GPIOA_ISR + offset, bitMap);
000004  e0800002          ADD      r0,r0,r2
000008  e5801018          STR      r1,[r0,#0x18]
;;;502    
;;;503        return SUCCESSFUL;
00000c  e3a00000          MOV      r0,#0
;;;504    }
000010  e12fff1e          BX       lr
;;;505    
                          ENDP

                  |L6.20|
                          DCD      0xb8003000

                          AREA ||i.GPIO_ClrISRBit||, CODE, READONLY, ALIGN=2

                  GPIO_ClrISRBit PROC
;;;516     */
;;;517    INT32 GPIO_ClrISRBit(GPIO_PORT port, UINT32 bit)
000000  e59f200c          LDR      r2,|L7.20|
;;;518    {
;;;519        UINT32 bitMap;
;;;520        INT32 offset;
;;;521    
;;;522        offset = (INT32)port;
;;;523        bitMap = (UINT32)bit;
;;;524    
;;;525        outpw(REG_GPIOA_ISR + offset, bitMap);
000004  e0800002          ADD      r0,r0,r2
000008  e5801018          STR      r1,[r0,#0x18]
;;;526    
;;;527        return SUCCESSFUL;
00000c  e3a00000          MOV      r0,#0
;;;528    }
000010  e12fff1e          BX       lr
;;;529    
                          ENDP

                  |L7.20|
                          DCD      0xb8003000

                          AREA ||i.GPIO_DisableDebounce||, CODE, READONLY, ALIGN=2

                  GPIO_DisableDebounce PROC
;;;919     */
;;;920    INT32 GPIO_DisableDebounce(void)
000000  e59f1014          LDR      r1,|L8.28|
;;;921    {
;;;922        UINT32 reg;
;;;923    
;;;924        reg = inpw(REG_GPIO_DBNCECON);
000004  e59103f0          LDR      r0,[r1,#0x3f0]
;;;925    
;;;926        /* Setting the debounce timing */
;;;927        reg = ((reg & ~0xf));
000008  e3c0000f          BIC      r0,r0,#0xf
;;;928    
;;;929        /* Enable the debounce function */
;;;930        reg = reg | 0x20;
00000c  e3800020          ORR      r0,r0,#0x20
;;;931        outpw(REG_GPIO_DBNCECON, reg);
000010  e58103f0          STR      r0,[r1,#0x3f0]
;;;932    
;;;933        return SUCCESSFUL;
000014  e3a00000          MOV      r0,#0
;;;934    }
000018  e12fff1e          BX       lr
;;;935    
                          ENDP

                  |L8.28|
                          DCD      0xb8003000

                          AREA ||i.GPIO_DisableEINT||, CODE, READONLY, ALIGN=2

                  GPIO_DisableEINT PROC
;;;861     */
;;;862    INT32 GPIO_DisableEINT(GPIO_NIRQ nIrq)
000000  e92d4010          PUSH     {r4,lr}
;;;863    {
000004  e1a04000          MOV      r4,r0
;;;864        sysDisableInterrupt((IRQn_Type)(nIrq+4));
000008  e2800004          ADD      r0,r0,#4
00000c  e20000ff          AND      r0,r0,#0xff
000010  ebfffffe          BL       sysDisableInterrupt
;;;865        gpioCfg.IRQCallback[nIrq] = NULL;
000014  e59f0014          LDR      r0,|L9.48|
000018  e3a01000          MOV      r1,#0
00001c  e0800104          ADD      r0,r0,r4,LSL #2
;;;866        gpioCfg.IRQUserData[nIrq] = 0;
000020  e5801014          STR      r1,[r0,#0x14]
000024  e580103c          STR      r1,[r0,#0x3c]
;;;867        return SUCCESSFUL;
000028  e1a00001          MOV      r0,r1
;;;868    }
00002c  e8bd8010          POP      {r4,pc}
;;;869    
                          ENDP

                  |L9.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_DisableInt||, CODE, READONLY, ALIGN=2

                  GPIO_DisableInt PROC
;;;668     */
;;;669    INT32 GPIO_DisableInt(GPIO_PORT port)
000000  e59f1048          LDR      r1,|L10.80|
;;;670    {
;;;671        INT32 i,portIndex;
;;;672        portIndex = (INT32)port/0x40;
000004  e1a00320          LSR      r0,r0,#6
000008  e92d4010          PUSH     {r4,lr}               ;670
;;;673    
;;;674        gpioCfg.IRQCallback[portIndex] = NULL;
00000c  e3a02000          MOV      r2,#0
000010  e0810100          ADD      r0,r1,r0,LSL #2
;;;675        gpioCfg.IRQUserData[portIndex] = 0;
000014  e5802014          STR      r2,[r0,#0x14]
000018  e580203c          STR      r2,[r0,#0x3c]
;;;676    
;;;677        for(i=0; i<MAX_PORT; i++)
00001c  e1a00002          MOV      r0,r2
                  |L10.32|
;;;678            if(gpioCfg.IRQCallback[i]!=0)
000020  e0812100          ADD      r2,r1,r0,LSL #2
000024  e5922014          LDR      r2,[r2,#0x14]
000028  e3520000          CMP      r2,#0
00002c  0a000001          BEQ      |L10.56|
                  |L10.48|
;;;679                return SUCCESSFUL;
000030  e3a00000          MOV      r0,#0
;;;680        sysDisableInterrupt(GPIO_IRQn);
;;;681        return SUCCESSFUL;
;;;682    }
000034  e8bd8010          POP      {r4,pc}
                  |L10.56|
000038  e2800001          ADD      r0,r0,#1              ;679
00003c  e350000a          CMP      r0,#0xa               ;677
000040  bafffff6          BLT      |L10.32|
000044  e3a00039          MOV      r0,#0x39              ;680
000048  ebfffffe          BL       sysDisableInterrupt
00004c  eafffff7          B        |L10.48|
;;;683    
                          ENDP

                  |L10.80|
                          DCD      ||.bss||

                          AREA ||i.GPIO_DisableTriggerType||, CODE, READONLY, ALIGN=2

                  GPIO_DisableTriggerType PROC
;;;832     */
;;;833    INT32 GPIO_DisableTriggerType(GPIO_PORT port, UINT32 bitMap)
000000  e59f202c          LDR      r2,|L11.52|
;;;834    {
;;;835        UINT32 reg;
;;;836        INT32 offset;
;;;837    
;;;838        offset = (INT32)port;
;;;839    
;;;840        reg = inpw(REG_GPIOA_IMD+offset);
000004  e0800002          ADD      r0,r0,r2
000008  e590200c          LDR      r2,[r0,#0xc]
;;;841        outpw(REG_GPIOA_IMD +offset,reg & ~bitMap);
00000c  e1c22001          BIC      r2,r2,r1
000010  e580200c          STR      r2,[r0,#0xc]
;;;842    
;;;843        reg = inpw(REG_GPIOA_IREN+offset);
000014  e5902010          LDR      r2,[r0,#0x10]
;;;844        outpw(REG_GPIOA_IREN+offset,reg & ~bitMap);
000018  e1c22001          BIC      r2,r2,r1
00001c  e5802010          STR      r2,[r0,#0x10]
;;;845    
;;;846        reg = inpw(REG_GPIOA_IFEN+offset);
000020  e5902014          LDR      r2,[r0,#0x14]
;;;847        outpw(REG_GPIOA_IFEN+offset,reg & ~bitMap);
000024  e1c21001          BIC      r1,r2,r1
000028  e5801014          STR      r1,[r0,#0x14]
;;;848    
;;;849        return SUCCESSFUL;
00002c  e3a00000          MOV      r0,#0
;;;850    }
000030  e12fff1e          BX       lr
;;;851    
                          ENDP

                  |L11.52|
                          DCD      0xb8003000

                          AREA ||i.GPIO_EnableDebounce||, CODE, READONLY, ALIGN=2

                  GPIO_EnableDebounce PROC
;;;895     */
;;;896    INT32 GPIO_EnableDebounce(INT32 debounceClkSel)
000000  e59f2018          LDR      r2,|L12.32|
;;;897    {
;;;898        UINT32 reg;
;;;899    
;;;900        reg = inpw(REG_GPIO_DBNCECON);
000004  e59213f0          LDR      r1,[r2,#0x3f0]
;;;901    
;;;902        /* Setting the debounce timing */
;;;903        reg = ((reg & ~0xf) | debounceClkSel);
000008  e3c1100f          BIC      r1,r1,#0xf
00000c  e1800001          ORR      r0,r0,r1
;;;904    
;;;905        /* Enable the debounce function */
;;;906        reg = reg | 0x20;
000010  e3800020          ORR      r0,r0,#0x20
;;;907        outpw(REG_GPIO_DBNCECON, reg);
000014  e58203f0          STR      r0,[r2,#0x3f0]
;;;908    
;;;909        return SUCCESSFUL;
000018  e3a00000          MOV      r0,#0
;;;910    }
00001c  e12fff1e          BX       lr
;;;911    
                          ENDP

                  |L12.32|
                          DCD      0xb8003000

                          AREA ||i.GPIO_EnableEINT||, CODE, READONLY, ALIGN=2

                  GPIO_EnableEINT PROC
;;;695     */
;;;696    INT32 GPIO_EnableEINT(GPIO_NIRQ nIrq, GPIO_CALLBACK callback, UINT32 userData)
000000  e92d4010          PUSH     {r4,lr}
;;;697    {
;;;698        if(callback != NULL) {
000004  e3510000          CMP      r1,#0
000008  e1a04000          MOV      r4,r0                 ;697
00000c  0a000003          BEQ      |L13.32|
;;;699            gpioCfg.EINTIRQCallback[nIrq] = (GPIO_CALLBACK)callback;
000010  e59f0104          LDR      r0,|L13.284|
000014  e0803104          ADD      r3,r0,r4,LSL #2
;;;700            gpioCfg.EINTIRQUserData[nIrq] = userData;
000018  e5a31064          STR      r1,[r3,#0x64]!
00001c  e5832020          STR      r2,[r3,#0x20]
                  |L13.32|
;;;701        }
;;;702        sysSetLocalInterrupt(ENABLE_IRQ);
000020  e3a0007f          MOV      r0,#0x7f
000024  ebfffffe          BL       sysSetLocalInterrupt
;;;703        switch(nIrq) {
000028  e3540008          CMP      r4,#8
00002c  308ff104          ADDCC    pc,pc,r4,LSL #2
000030  ea000013          B        |L13.132|
000034  ea000006          B        |L13.84|
000038  ea00000b          B        |L13.108|
00003c  ea000012          B        |L13.140|
000040  ea000017          B        |L13.164|
000044  ea00001c          B        |L13.188|
000048  ea000021          B        |L13.212|
00004c  ea000026          B        |L13.236|
000050  ea00002b          B        |L13.260|
                  |L13.84|
;;;704        case 0:
;;;705            sysInstallISR(IRQ_LEVEL_7, EINT0_IRQn, (PVOID)GPIO_IRQHandler0);
000054  e59f20c4          LDR      r2,|L13.288|
000058  e3a01004          MOV      r1,#4
00005c  e3a00007          MOV      r0,#7
000060  ebfffffe          BL       sysInstallISR
;;;706            sysEnableInterrupt(EINT0_IRQn);
000064  e3a00004          MOV      r0,#4
;;;707            break;
000068  ea000004          B        |L13.128|
                  |L13.108|
;;;708    
;;;709        case 1:
;;;710            sysInstallISR(IRQ_LEVEL_7, EINT1_IRQn, (PVOID)GPIO_IRQHandler1);
00006c  e59f20b0          LDR      r2,|L13.292|
000070  e3a01005          MOV      r1,#5
000074  e3a00007          MOV      r0,#7
000078  ebfffffe          BL       sysInstallISR
;;;711            sysEnableInterrupt(EINT1_IRQn);
00007c  e3a00005          MOV      r0,#5
                  |L13.128|
000080  ebfffffe          BL       sysEnableInterrupt
                  |L13.132|
;;;712            break;
;;;713    
;;;714        case 2:
;;;715            sysInstallISR(IRQ_LEVEL_7, EINT2_IRQn, (PVOID)GPIO_IRQHandler2);
;;;716            sysEnableInterrupt(EINT2_IRQn);
;;;717            break;
;;;718    
;;;719        case 3:
;;;720            sysInstallISR(IRQ_LEVEL_7, EINT3_IRQn, (PVOID)GPIO_IRQHandler3);
;;;721            sysEnableInterrupt(EINT3_IRQn);
;;;722            break;
;;;723    
;;;724        case 4:
;;;725            sysInstallISR(IRQ_LEVEL_7, EINT4_IRQn, (PVOID)GPIO_IRQHandler4);
;;;726            sysEnableInterrupt(EINT4_IRQn);
;;;727            break;
;;;728    
;;;729        case 5:
;;;730            sysInstallISR(IRQ_LEVEL_7, EINT5_IRQn, (PVOID)GPIO_IRQHandler5);
;;;731            sysEnableInterrupt(EINT5_IRQn);
;;;732            break;
;;;733    
;;;734        case 6:
;;;735            sysInstallISR(IRQ_LEVEL_7, EINT6_IRQn, (PVOID)GPIO_IRQHandler6);
;;;736            sysEnableInterrupt(EINT6_IRQn);
;;;737            break;
;;;738    
;;;739        case 7:
;;;740            sysInstallISR(IRQ_LEVEL_7, EINT7_IRQn, (PVOID)GPIO_IRQHandler7);
;;;741            sysEnableInterrupt(EINT7_IRQn);
;;;742            break;
;;;743        };
;;;744        return SUCCESSFUL;
000084  e3a00000          MOV      r0,#0
;;;745    }
000088  e8bd8010          POP      {r4,pc}
                  |L13.140|
00008c  e59f2094          LDR      r2,|L13.296|
000090  e3a01006          MOV      r1,#6                 ;715
000094  e3a00007          MOV      r0,#7                 ;715
000098  ebfffffe          BL       sysInstallISR
00009c  e3a00006          MOV      r0,#6                 ;716
0000a0  eafffff6          B        |L13.128|
                  |L13.164|
0000a4  e3a01007          MOV      r1,#7                 ;720
0000a8  e59f207c          LDR      r2,|L13.300|
0000ac  e1a00001          MOV      r0,r1                 ;720
0000b0  ebfffffe          BL       sysInstallISR
0000b4  e3a00007          MOV      r0,#7                 ;721
0000b8  eafffff0          B        |L13.128|
                  |L13.188|
0000bc  e59f206c          LDR      r2,|L13.304|
0000c0  e3a01008          MOV      r1,#8                 ;725
0000c4  e3a00007          MOV      r0,#7                 ;725
0000c8  ebfffffe          BL       sysInstallISR
0000cc  e3a00008          MOV      r0,#8                 ;726
0000d0  eaffffea          B        |L13.128|
                  |L13.212|
0000d4  e59f2058          LDR      r2,|L13.308|
0000d8  e3a01009          MOV      r1,#9                 ;730
0000dc  e3a00007          MOV      r0,#7                 ;730
0000e0  ebfffffe          BL       sysInstallISR
0000e4  e3a00009          MOV      r0,#9                 ;731
0000e8  eaffffe4          B        |L13.128|
                  |L13.236|
0000ec  e59f2044          LDR      r2,|L13.312|
0000f0  e3a0100a          MOV      r1,#0xa               ;735
0000f4  e3a00007          MOV      r0,#7                 ;735
0000f8  ebfffffe          BL       sysInstallISR
0000fc  e3a0000a          MOV      r0,#0xa               ;736
000100  eaffffde          B        |L13.128|
                  |L13.260|
000104  e59f2030          LDR      r2,|L13.316|
000108  e3a0100b          MOV      r1,#0xb               ;740
00010c  e3a00007          MOV      r0,#7                 ;740
000110  ebfffffe          BL       sysInstallISR
000114  e3a0000b          MOV      r0,#0xb               ;741
000118  eaffffd8          B        |L13.128|
;;;746    
                          ENDP

                  |L13.284|
                          DCD      ||.bss||
                  |L13.288|
                          DCD      GPIO_IRQHandler0
                  |L13.292|
                          DCD      GPIO_IRQHandler1
                  |L13.296|
                          DCD      GPIO_IRQHandler2
                  |L13.300|
                          DCD      GPIO_IRQHandler3
                  |L13.304|
                          DCD      GPIO_IRQHandler4
                  |L13.308|
                          DCD      GPIO_IRQHandler5
                  |L13.312|
                          DCD      GPIO_IRQHandler6
                  |L13.316|
                          DCD      GPIO_IRQHandler7

                          AREA ||i.GPIO_EnableInt||, CODE, READONLY, ALIGN=2

                  GPIO_EnableInt PROC
;;;645     */
;;;646    INT32 GPIO_EnableInt(GPIO_PORT port, GPIO_CALLBACK callback, UINT32 userData)
000000  e92d4010          PUSH     {r4,lr}
;;;647    {
;;;648        INT32 portIndex;
;;;649        portIndex = (INT32)port/0x40;
;;;650        if(callback != NULL) {
000004  e3510000          CMP      r1,#0
000008  e1a00320          LSR      r0,r0,#6              ;649
00000c  0a000003          BEQ      |L14.32|
;;;651            gpioCfg.IRQCallback[portIndex] = (GPIO_CALLBACK)callback;
000010  e59f3028          LDR      r3,|L14.64|
000014  e0830100          ADD      r0,r3,r0,LSL #2
;;;652            gpioCfg.IRQUserData[portIndex] = userData;
000018  e5a01014          STR      r1,[r0,#0x14]!
00001c  e5802028          STR      r2,[r0,#0x28]
                  |L14.32|
;;;653        }
;;;654        sysInstallISR(IRQ_LEVEL_7, GPIO_IRQn, (PVOID)GPIO_IRQHandler);
000020  e59f201c          LDR      r2,|L14.68|
000024  e3a01039          MOV      r1,#0x39
000028  e3a00007          MOV      r0,#7
00002c  ebfffffe          BL       sysInstallISR
;;;655        sysEnableInterrupt(GPIO_IRQn);
000030  e3a00039          MOV      r0,#0x39
000034  ebfffffe          BL       sysEnableInterrupt
;;;656        return SUCCESSFUL;
000038  e3a00000          MOV      r0,#0
;;;657    }
00003c  e8bd8010          POP      {r4,pc}
;;;658    
                          ENDP

                  |L14.64|
                          DCD      ||.bss||
                  |L14.68|
                          DCD      GPIO_IRQHandler

                          AREA ||i.GPIO_EnableTriggerType||, CODE, READONLY, ALIGN=2

                  GPIO_EnableTriggerType PROC
;;;759     */
;;;760    INT32 GPIO_EnableTriggerType(GPIO_PORT port, UINT32 bitMap, GPIO_TRIGGER_TYPE triggerType)
000000  e59f30a4          LDR      r3,|L15.172|
;;;761    {
;;;762        UINT32 reg;
;;;763        INT32 offset;
;;;764    
;;;765        offset = (INT32)port;
;;;766    
;;;767        switch(triggerType) {
000004  e3520005          CMP      r2,#5
;;;768        case LOW:
;;;769            reg = inpw(REG_GPIOA_IMD+offset);
000008  e0800003          ADD      r0,r0,r3
00000c  308ff102          ADDCC    pc,pc,r2,LSL #2       ;767
000010  ea00000b          B        |L15.68|
000014  ea000003          B        |L15.40|
000018  ea000005          B        |L15.52|
00001c  ea00000a          B        |L15.76|
000020  ea00000f          B        |L15.100|
000024  ea000017          B        |L15.136|
                  |L15.40|
000028  e590200c          LDR      r2,[r0,#0xc]
;;;770            outpw(REG_GPIOA_IMD+offset,reg | bitMap);
00002c  e1822001          ORR      r2,r2,r1
;;;771    
;;;772            reg = inpw(REG_GPIOA_IREN+offset);
;;;773            outpw(REG_GPIOA_IREN+offset,reg & ~bitMap);
;;;774    
;;;775            reg = inpw(REG_GPIOA_IFEN+offset);
;;;776            outpw(REG_GPIOA_IFEN+offset,reg  | bitMap);
;;;777            break;
000030  ea000007          B        |L15.84|
                  |L15.52|
;;;778        case HIGH:
;;;779            reg = inpw(REG_GPIOA_IMD+offset);
000034  e590200c          LDR      r2,[r0,#0xc]
;;;780            outpw(REG_GPIOA_IMD+offset,reg | bitMap);
000038  e1822001          ORR      r2,r2,r1
;;;781    
;;;782            reg = inpw(REG_GPIOA_IREN+offset);
;;;783            outpw(REG_GPIOA_IREN+offset,reg | bitMap);
;;;784    
;;;785            reg = inpw(REG_GPIOA_IFEN+offset);
;;;786            outpw(REG_GPIOA_IFEN+offset,reg & ~bitMap);
;;;787            break;
00003c  ea00000a          B        |L15.108|
                  |L15.64|
000040  e5801014          STR      r1,[r0,#0x14]         ;776
                  |L15.68|
;;;788        case FALLING:
;;;789            reg = inpw(REG_GPIOA_IMD+offset);
;;;790            outpw(REG_GPIOA_IMD+offset,reg & ~bitMap);
;;;791    
;;;792            reg = inpw(REG_GPIOA_IREN+offset);
;;;793            outpw(REG_GPIOA_IREN+offset,reg & ~bitMap);
;;;794    
;;;795            reg = inpw(REG_GPIOA_IFEN+offset);
;;;796            outpw(REG_GPIOA_IFEN+offset,reg  | bitMap);
;;;797            break;
;;;798        case RISING:
;;;799            reg = inpw(REG_GPIOA_IMD+offset);
;;;800            outpw(REG_GPIOA_IMD+offset,reg & ~bitMap);
;;;801    
;;;802            reg = inpw(REG_GPIOA_IREN+offset);
;;;803            outpw(REG_GPIOA_IREN+offset,reg | bitMap);
;;;804    
;;;805            reg = inpw(REG_GPIOA_IFEN+offset);
;;;806            outpw(REG_GPIOA_IFEN+offset,reg & ~bitMap);
;;;807            break;
;;;808        case BOTH_EDGE:
;;;809            reg = inpw(REG_GPIOA_IMD+offset);
;;;810            outpw(REG_GPIOA_IMD+offset,reg & ~bitMap);
;;;811    
;;;812            reg = inpw(REG_GPIOA_IREN+offset);
;;;813            outpw(REG_GPIOA_IREN+offset,reg | bitMap);
;;;814    
;;;815            reg = inpw(REG_GPIOA_IFEN+offset);
;;;816            outpw(REG_GPIOA_IFEN+offset,reg | bitMap);
;;;817            break;
;;;818        }
;;;819        return SUCCESSFUL;
000044  e3a00000          MOV      r0,#0
;;;820    }
000048  e12fff1e          BX       lr
                  |L15.76|
00004c  e590200c          LDR      r2,[r0,#0xc]          ;789
000050  e1c22001          BIC      r2,r2,r1              ;790
                  |L15.84|
000054  e580200c          STR      r2,[r0,#0xc]          ;770
000058  e5902010          LDR      r2,[r0,#0x10]         ;772
00005c  e1c22001          BIC      r2,r2,r1              ;773
000060  ea00000d          B        |L15.156|
                  |L15.100|
000064  e590200c          LDR      r2,[r0,#0xc]          ;799
000068  e1c22001          BIC      r2,r2,r1              ;800
                  |L15.108|
00006c  e580200c          STR      r2,[r0,#0xc]          ;800
000070  e5902010          LDR      r2,[r0,#0x10]         ;802
000074  e1822001          ORR      r2,r2,r1              ;803
000078  e5802010          STR      r2,[r0,#0x10]         ;803
00007c  e5902014          LDR      r2,[r0,#0x14]         ;805
000080  e1c21001          BIC      r1,r2,r1              ;806
000084  eaffffed          B        |L15.64|
                  |L15.136|
000088  e590200c          LDR      r2,[r0,#0xc]          ;809
00008c  e1c22001          BIC      r2,r2,r1              ;810
000090  e580200c          STR      r2,[r0,#0xc]          ;810
000094  e5902010          LDR      r2,[r0,#0x10]         ;812
000098  e1822001          ORR      r2,r2,r1              ;813
                  |L15.156|
00009c  e5802010          STR      r2,[r0,#0x10]         ;813
0000a0  e5902014          LDR      r2,[r0,#0x14]         ;815
0000a4  e1811002          ORR      r1,r1,r2              ;816
0000a8  eaffffe4          B        |L15.64|
;;;821    
                          ENDP

                  |L15.172|
                          DCD      0xb8003000

                          AREA ||i.GPIO_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler PROC
;;;36      */
;;;37     void GPIO_IRQHandler(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;38     {
;;;39         UINT32 reg;
;;;40         INT32 i,mask;
;;;41         reg = inpw(REG_AIC_ISRH);
000004  e59f8054          LDR      r8,|L16.96|
000008  e5980114          LDR      r0,[r8,#0x114]
;;;42         mask = 0x02000000; /* INT56 */
00000c  e3a06402          MOV      r6,#0x2000000
;;;43         reg = inpw(REG_GPIO_ISR);
000010  e18876c6          ORR      r7,r8,r6,ASR #13
000014  e59753fc          LDR      r5,[r7,#0x3fc]
;;;44         for(i=0; i<MAX_PORT; i++)
;;;45             if( gpioCfg.IRQCallback[i] != NULL && (reg & (1<<i)) ) {
000018  e59f9044          LDR      r9,|L16.100|
00001c  e3a04000          MOV      r4,#0                 ;44
000020  e3a0a001          MOV      r10,#1
                  |L16.36|
000024  e0890104          ADD      r0,r9,r4,LSL #2
000028  e5902014          LDR      r2,[r0,#0x14]
00002c  e3520000          CMP      r2,#0
000030  11a0141a          LSLNE    r1,r10,r4
000034  11110005          TSTNE    r1,r5
000038  0a000003          BEQ      |L16.76|
;;;46                 gpioCfg.IRQCallback[i](inpw(REG_GPIOA_ISR+i*0x40), gpioCfg.IRQUserData[i]);
00003c  e590103c          LDR      r1,[r0,#0x3c]
000040  e0870304          ADD      r0,r7,r4,LSL #6
000044  e5900018          LDR      r0,[r0,#0x18]
000048  e12fff32          BLX      r2
                  |L16.76|
00004c  e2844001          ADD      r4,r4,#1
000050  e354000a          CMP      r4,#0xa               ;44
;;;47             }
;;;48         outpw(REG_AIC_SCCRH, mask);   /* Clear interrupt */
000054  a588614c          STRGE    r6,[r8,#0x14c]
000058  bafffff1          BLT      |L16.36|
;;;49     }
00005c  e8bd87f0          POP      {r4-r10,pc}
;;;50     
                          ENDP

                  |L16.96|
                          DCD      0xb8002000
                  |L16.100|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler0||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler0 PROC
;;;55      */
;;;56     void GPIO_IRQHandler0(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;57     {
;;;58         UINT32 reg;
;;;59         INT32 mask;
;;;60         reg = inpw(REG_AIC_ISR);
000004  e59f5020          LDR      r5,|L17.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;61         mask = 0x10;
;;;62         if(gpioCfg.EINTIRQCallback[0] != NULL) {
00000c  e59f101c          LDR      r1,|L17.48|
000010  e3a04010          MOV      r4,#0x10              ;61
000014  e5912064          LDR      r2,[r1,#0x64]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;63             gpioCfg.EINTIRQCallback[0](reg, gpioCfg.EINTIRQUserData[0]);
00001c  15911084          LDRNE    r1,[r1,#0x84]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;64         }
;;;65         outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;66     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;67     
                          ENDP

                  |L17.44|
                          DCD      0xb8002000
                  |L17.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler1||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler1 PROC
;;;72      */
;;;73     void GPIO_IRQHandler1(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;74     {
;;;75         UINT32 reg;
;;;76         INT32 mask;
;;;77         reg = inpw(REG_AIC_ISR);
000004  e59f5020          LDR      r5,|L18.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;78         mask = 0x20;
;;;79         if(gpioCfg.EINTIRQCallback[1] != NULL) {
00000c  e59f101c          LDR      r1,|L18.48|
000010  e3a04020          MOV      r4,#0x20              ;78
000014  e5912068          LDR      r2,[r1,#0x68]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;80             gpioCfg.EINTIRQCallback[1](reg, gpioCfg.EINTIRQUserData[1]);
00001c  15911088          LDRNE    r1,[r1,#0x88]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;81         }
;;;82         outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;83     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;84     
                          ENDP

                  |L18.44|
                          DCD      0xb8002000
                  |L18.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler2||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler2 PROC
;;;89      */
;;;90     void GPIO_IRQHandler2(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;91     {
;;;92         UINT32 reg;
;;;93         INT32 mask;
;;;94         reg = inpw(REG_AIC_ISR);
000004  e59f5020          LDR      r5,|L19.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;95         mask = 0x40;
;;;96         if(gpioCfg.EINTIRQCallback[2] != NULL) {
00000c  e59f101c          LDR      r1,|L19.48|
000010  e3a04040          MOV      r4,#0x40              ;95
000014  e591206c          LDR      r2,[r1,#0x6c]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;97             gpioCfg.EINTIRQCallback[2](reg, gpioCfg.EINTIRQUserData[2]);
00001c  1591108c          LDRNE    r1,[r1,#0x8c]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;98         }
;;;99         outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;100    }
000028  e8bd8070          POP      {r4-r6,pc}
;;;101    
                          ENDP

                  |L19.44|
                          DCD      0xb8002000
                  |L19.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler3||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler3 PROC
;;;106     */
;;;107    void GPIO_IRQHandler3(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;108    {
;;;109        UINT32 reg;
;;;110        INT32 mask;
;;;111        reg = inpw(REG_AIC_ISR);
000004  e59f5020          LDR      r5,|L20.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;112        mask = 0x80;
;;;113        if(gpioCfg.EINTIRQCallback[3] != NULL) {
00000c  e59f101c          LDR      r1,|L20.48|
000010  e3a04080          MOV      r4,#0x80              ;112
000014  e5912070          LDR      r2,[r1,#0x70]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;114            gpioCfg.EINTIRQCallback[3](reg, gpioCfg.EINTIRQUserData[3]);
00001c  15911090          LDRNE    r1,[r1,#0x90]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;115        }
;;;116        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;117    }
000028  e8bd8070          POP      {r4-r6,pc}
;;;118    
                          ENDP

                  |L20.44|
                          DCD      0xb8002000
                  |L20.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler4||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler4 PROC
;;;123     */
;;;124    void GPIO_IRQHandler4(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;125    {
;;;126        UINT32 reg;
;;;127        INT32 mask;
;;;128        reg = inpw(REG_AIC_ISR);
000004  e59f5020          LDR      r5,|L21.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;129        mask = 0x100;
;;;130        if(gpioCfg.EINTIRQCallback[4] != NULL) {
00000c  e59f101c          LDR      r1,|L21.48|
000010  e3a04c01          MOV      r4,#0x100             ;129
000014  e5912074          LDR      r2,[r1,#0x74]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;131            gpioCfg.EINTIRQCallback[4](reg, gpioCfg.EINTIRQUserData[4]);
00001c  15911094          LDRNE    r1,[r1,#0x94]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;132        }
;;;133        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;134    }
000028  e8bd8070          POP      {r4-r6,pc}
;;;135    
                          ENDP

                  |L21.44|
                          DCD      0xb8002000
                  |L21.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler5||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler5 PROC
;;;140     */
;;;141    void GPIO_IRQHandler5(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;142    {
;;;143        UINT32 reg;
;;;144        INT32 mask;
;;;145        reg = inpw(REG_AIC_ISR);
000004  e59f5020          LDR      r5,|L22.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;146        mask = 0x200;
;;;147        if(gpioCfg.EINTIRQCallback[5] != NULL) {
00000c  e59f101c          LDR      r1,|L22.48|
000010  e3a04c02          MOV      r4,#0x200             ;146
000014  e5912078          LDR      r2,[r1,#0x78]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;148            gpioCfg.EINTIRQCallback[5](reg, gpioCfg.EINTIRQUserData[5]);
00001c  15911098          LDRNE    r1,[r1,#0x98]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;149        }
;;;150        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;151    }
000028  e8bd8070          POP      {r4-r6,pc}
;;;152    
                          ENDP

                  |L22.44|
                          DCD      0xb8002000
                  |L22.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler6||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler6 PROC
;;;157     */
;;;158    void GPIO_IRQHandler6(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;159    {
;;;160        UINT32 reg;
;;;161        INT32 mask;
;;;162        reg = inpw(REG_AIC_ISR);
000004  e59f5020          LDR      r5,|L23.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;163        mask = 0x400;
;;;164        if(gpioCfg.EINTIRQCallback[6] != NULL) {
00000c  e59f101c          LDR      r1,|L23.48|
000010  e3a04b01          MOV      r4,#0x400             ;163
000014  e591207c          LDR      r2,[r1,#0x7c]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;165            gpioCfg.EINTIRQCallback[6](reg, gpioCfg.EINTIRQUserData[6]);
00001c  1591109c          LDRNE    r1,[r1,#0x9c]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;166        }
;;;167        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;168    }
000028  e8bd8070          POP      {r4-r6,pc}
;;;169    
                          ENDP

                  |L23.44|
                          DCD      0xb8002000
                  |L23.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler7||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler7 PROC
;;;174     */
;;;175    void GPIO_IRQHandler7(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;176    {
;;;177        UINT32 reg;
;;;178        INT32 mask;
;;;179        reg = inpw(REG_AIC_ISR);
000004  e59f5020          LDR      r5,|L24.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;180        mask = 0x800;
;;;181        if(gpioCfg.EINTIRQCallback[7] != NULL) {
00000c  e59f101c          LDR      r1,|L24.48|
000010  e3a04b02          MOV      r4,#0x800             ;180
000014  e5912080          LDR      r2,[r1,#0x80]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;182            gpioCfg.EINTIRQCallback[7](reg, gpioCfg.EINTIRQUserData[7]);
00001c  159110a0          LDRNE    r1,[r1,#0xa0]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;183        }
;;;184        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;185    }
000028  e8bd8070          POP      {r4-r6,pc}
;;;186    
                          ENDP

                  |L24.44|
                          DCD      0xb8002000
                  |L24.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_Open||, CODE, READONLY, ALIGN=2

                  GPIO_Open PROC
;;;198     */
;;;199    INT32 GPIO_Open(GPIO_PORT port, GPIO_DIR direction, GPIO_PULL pull)
000000  e92d4010          PUSH     {r4,lr}
;;;200    {
;;;201        UINT32 mask;
;;;202        INT32 portIndex;
;;;203        INT32 offset;
;;;204    
;;;205        outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
000004  e3a0320b          MOV      r3,#0xb0000000
000008  e593c218          LDR      r12,[r3,#0x218]
00000c  e38cc008          ORR      r12,r12,#8
000010  e583c218          STR      r12,[r3,#0x218]
;;;206    	
;;;207    	
;;;208        offset = (INT32)port;
;;;209        portIndex = port / 0x40;
;;;210        mask = maskTbl[portIndex];
000014  e59f304c          LDR      r3,|L25.104|
;;;211    
;;;212        if(gpioCfg.bitBusyFlag[portIndex] != 0) {
000018  e59f404c          LDR      r4,|L25.108|
00001c  e1a0c320          LSR      r12,r0,#6             ;209
000020  e793310c          LDR      r3,[r3,r12,LSL #2]    ;210
000024  e084c08c          ADD      r12,r4,r12,LSL #1
000028  e1dc40b0          LDRH     r4,[r12,#0]
00002c  e3540000          CMP      r4,#0
;;;213            return GPIO_ERR_PORT_BUSY;
000030  13e00000          MVNNE    r0,#0
;;;214        }
;;;215    
;;;216        /* Set all bits in the port to busy */
;;;217        gpioCfg.bitBusyFlag[portIndex] = mask;
;;;218    
;;;219        /* Set port direction */
;;;220        if(direction == DIR_OUTPUT) {
;;;221            outpw(REG_GPIOA_DIR + offset , mask);
;;;222        } else {
;;;223            outpw(REG_GPIOA_DIR + offset , 0);
;;;224        }
;;;225    
;;;226        if(pull == PULL_UP) {
;;;227            outpw(REG_GPIOA_PUEN + offset , mask);
;;;228        } else {
;;;229            outpw(REG_GPIOA_PUEN + offset , 0);
;;;230        }
;;;231    
;;;232        return SUCCESSFUL;
;;;233    }
000034  18bd8010          POPNE    {r4,pc}
000038  e1cc30b0          STRH     r3,[r12,#0]           ;217
00003c  e59f402c          LDR      r4,|L25.112|
000040  e3510001          CMP      r1,#1                 ;220
000044  e0800004          ADD      r0,r0,r4              ;221
000048  e3a0c000          MOV      r12,#0                ;217
00004c  05803000          STREQ    r3,[r0,#0]            ;221
000050  1580c000          STRNE    r12,[r0,#0]           ;223
000054  e3520001          CMP      r2,#1                 ;226
000058  05803020          STREQ    r3,[r0,#0x20]         ;227
00005c  1580c020          STRNE    r12,[r0,#0x20]        ;229
000060  e3a00000          MOV      r0,#0                 ;232
000064  e8bd8010          POP      {r4,pc}
;;;234    
                          ENDP

                  |L25.104|
                          DCD      ||.data||
                  |L25.108|
                          DCD      ||.bss||
                  |L25.112|
                          DCD      0xb8003000

                          AREA ||i.GPIO_OpenBit||, CODE, READONLY, ALIGN=2

                  GPIO_OpenBit PROC
;;;378     */
;;;379    INT32 GPIO_OpenBit(GPIO_PORT port, UINT32 bit, GPIO_DIR direction, GPIO_PULL pull)
000000  e92d4030          PUSH     {r4,r5,lr}
;;;380    {
;;;381        UINT32 reg;
;;;382        UINT32 mask;
;;;383        INT32 portIndex;
;;;384        INT32 offset;
;;;385    
;;;386        offset = (INT32)port;
;;;387        portIndex = (port / 0x040);
;;;388        mask = (UINT32)bit;
;;;389    
;;;390    	 //add by qlqc
;;;391    	  outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
000004  e3a0420b          MOV      r4,#0xb0000000
000008  e5945218          LDR      r5,[r4,#0x218]
00000c  e1a0c320          LSR      r12,r0,#6             ;387
000010  e3855008          ORR      r5,r5,#8
000014  e5845218          STR      r5,[r4,#0x218]
;;;392    	 //add end
;;;393    	
;;;394        if((gpioCfg.bitBusyFlag[portIndex]&mask) != 0) {
000018  e59f404c          LDR      r4,|L26.108|
00001c  e084c08c          ADD      r12,r4,r12,LSL #1
000020  e1dc40b0          LDRH     r4,[r12,#0]
000024  e1140001          TST      r4,r1
;;;395            return GPIO_ERR_BIT_BUSY;
000028  13e00002          MVNNE    r0,#2
;;;396        }
;;;397    
;;;398        gpioCfg.bitBusyFlag[portIndex] = gpioCfg.bitBusyFlag[portIndex] | mask;
;;;399    
;;;400        reg = inpw(REG_GPIOA_DIR + offset);
;;;401        reg = reg & (~mask);
;;;402    
;;;403        if(direction == DIR_OUTPUT) {
;;;404            reg = reg | mask;
;;;405        }
;;;406    
;;;407        outpw(REG_GPIOA_DIR + offset, reg);
;;;408    
;;;409        reg = inpw(REG_GPIOA_PUEN + offset);
;;;410        reg = reg & (~mask);
;;;411    
;;;412        if(pull == PULL_UP) {
;;;413            reg = reg | mask;
;;;414        }
;;;415    
;;;416        outpw(REG_GPIOA_PUEN + offset, reg);
;;;417    
;;;418        return SUCCESSFUL;
;;;419    }
00002c  18bd8030          POPNE    {r4,r5,pc}
000030  e1844001          ORR      r4,r4,r1              ;398
000034  e1cc40b0          STRH     r4,[r12,#0]           ;398
000038  e59fc030          LDR      r12,|L26.112|
00003c  e7b0c00c          LDR      r12,[r0,r12]!         ;400
000040  e3520001          CMP      r2,#1                 ;403
000044  e1ccc001          BIC      r12,r12,r1            ;401
000048  018cc001          ORREQ    r12,r12,r1            ;404
00004c  e580c000          STR      r12,[r0,#0]           ;407
000050  e5902020          LDR      r2,[r0,#0x20]         ;409
000054  e3530001          CMP      r3,#1                 ;412
000058  e1c22001          BIC      r2,r2,r1              ;410
00005c  01822001          ORREQ    r2,r2,r1              ;413
000060  e5802020          STR      r2,[r0,#0x20]         ;416
000064  e3a00000          MOV      r0,#0                 ;418
000068  e8bd8030          POP      {r4,r5,pc}
;;;420    
                          ENDP

                  |L26.108|
                          DCD      ||.bss||
                  |L26.112|
                          DCD      0xb8003000

                          AREA ||i.GPIO_ReadBit||, CODE, READONLY, ALIGN=2

                  GPIO_ReadBit PROC
;;;566    */
;;;567    INT32 GPIO_ReadBit(GPIO_PORT port, UINT32 bit)
000000  e59f2010          LDR      r2,|L27.24|
;;;568    {
;;;569        UINT32 reg;
;;;570        UINT32 bitMap;
;;;571        INT32 offset;
;;;572    
;;;573        offset = (INT32)port;
;;;574        bitMap = (UINT32)bit;
;;;575    
;;;576        reg = inpw(REG_GPIOA_DATAIN + offset);
000004  e0800002          ADD      r0,r0,r2
000008  e5900008          LDR      r0,[r0,#8]
;;;577    
;;;578        return ((reg & bitMap)?1:0);
00000c  e0100001          ANDS     r0,r0,r1
000010  13a00001          MOVNE    r0,#1
;;;579    }
000014  e12fff1e          BX       lr
;;;580    
                          ENDP

                  |L27.24|
                          DCD      0xb8003000

                          AREA ||i.GPIO_ReadPort||, CODE, READONLY, ALIGN=2

                  GPIO_ReadPort PROC
;;;324    */
;;;325    UINT32 GPIO_ReadPort(GPIO_PORT port)
000000  e59f1008          LDR      r1,|L28.16|
;;;326    {
;;;327        UINT32 reg;
;;;328        INT32 offset;
;;;329    
;;;330        offset = (INT32)port;
;;;331    
;;;332        reg = inpw(REG_GPIOA_DATAIN + offset);
000004  e0800001          ADD      r0,r0,r1
000008  e5900008          LDR      r0,[r0,#8]
;;;333    
;;;334        return reg;
;;;335    }
00000c  e12fff1e          BX       lr
;;;336    
                          ENDP

                  |L28.16|
                          DCD      0xb8003000

                          AREA ||i.GPIO_Set||, CODE, READONLY, ALIGN=2

                  GPIO_Set PROC
;;;275     */
;;;276    INT32 GPIO_Set(GPIO_PORT port, UINT32 bitMap)
000000  e59f2014          LDR      r2,|L29.28|
;;;277    {
;;;278        INT32 offset;
;;;279        INT32 reg;
;;;280    
;;;281        offset = (INT32)port;
;;;282    
;;;283        reg = inpw(REG_GPIOA_DATAOUT + offset);
000004  e0800002          ADD      r0,r0,r2
000008  e5902004          LDR      r2,[r0,#4]
;;;284        reg = reg | bitMap;
00000c  e1811002          ORR      r1,r1,r2
;;;285        outpw(REG_GPIOA_DATAOUT + offset, reg);
000010  e5801004          STR      r1,[r0,#4]
;;;286    
;;;287        return SUCCESSFUL;
000014  e3a00000          MOV      r0,#0
;;;288    }
000018  e12fff1e          BX       lr
;;;289    
                          ENDP

                  |L29.28|
                          DCD      0xb8003000

                          AREA ||i.GPIO_SetBit||, CODE, READONLY, ALIGN=2

                  GPIO_SetBit PROC
;;;467     */
;;;468    INT32 GPIO_SetBit(GPIO_PORT port, UINT32 bit)
000000  e59f2014          LDR      r2,|L30.28|
;;;469    {
;;;470        UINT32 bitMap;
;;;471        INT32 offset;
;;;472        INT32 reg;
;;;473    
;;;474        offset = (INT32)port;
;;;475        bitMap = (UINT32)bit;
;;;476    
;;;477        reg = inpw(REG_GPIOA_DATAOUT + offset);
000004  e0800002          ADD      r0,r0,r2
000008  e5902004          LDR      r2,[r0,#4]
;;;478        reg = reg | bitMap;
00000c  e1811002          ORR      r1,r1,r2
;;;479        outpw(REG_GPIOA_DATAOUT + offset, reg);
000010  e5801004          STR      r1,[r0,#4]
;;;480    
;;;481        return SUCCESSFUL;
000014  e3a00000          MOV      r0,#0
;;;482    }
000018  e12fff1e          BX       lr
;;;483    
                          ENDP

                  |L30.28|
                          DCD      0xb8003000

                          AREA ||i.GPIO_SetBitDir||, CODE, READONLY, ALIGN=2

                  GPIO_SetBitDir PROC
;;;592    */
;;;593    INT32 GPIO_SetBitDir(GPIO_PORT port, UINT32 bit, GPIO_DIR direction)
000000  e59f301c          LDR      r3,|L31.36|
;;;594    {
;;;595        UINT32 reg;
;;;596        UINT32 bitMap;
;;;597        INT32 offset;
;;;598    
;;;599        offset = (INT32)port;
;;;600        bitMap = (UINT32)bit;
;;;601    
;;;602        reg = inpw(REG_GPIOA_DIR + offset);
000004  e0833000          ADD      r3,r3,r0
000008  e5930000          LDR      r0,[r3,#0]
;;;603        reg = reg & (~bitMap);
;;;604    
;;;605        if(direction == DIR_OUTPUT) {
00000c  e3520001          CMP      r2,#1
000010  e1c00001          BIC      r0,r0,r1              ;603
;;;606            reg = reg | bitMap;
000014  01800001          ORREQ    r0,r0,r1
;;;607        }
;;;608    
;;;609        outpw(REG_GPIOA_DIR + offset, reg);
000018  e5830000          STR      r0,[r3,#0]
;;;610    
;;;611        return SUCCESSFUL;
00001c  e3a00000          MOV      r0,#0
;;;612    }
000020  e12fff1e          BX       lr
;;;613    
                          ENDP

                  |L31.36|
                          DCD      0xb8003000

                          AREA ||i.GPIO_SetPortDir||, CODE, READONLY, ALIGN=2

                  GPIO_SetPortDir PROC
;;;346    */
;;;347    INT32 GPIO_SetPortDir(GPIO_PORT port, GPIO_DIR direction)
000000  e59f3024          LDR      r3,|L32.44|
;;;348    {
;;;349        INT32 offset;
;;;350        INT32 mask;
;;;351        INT32 portIndex;
;;;352    
;;;353        offset = (INT32)port;
;;;354        portIndex = (port / 0x40);
000004  e1a02320          LSR      r2,r0,#6
;;;355        mask = maskTbl[portIndex];
000008  e7932102          LDR      r2,[r3,r2,LSL #2]
;;;356    
;;;357        if(direction == DIR_OUTPUT) {
;;;358            outpw(REG_GPIOA_DIR + offset, mask);
00000c  e59f301c          LDR      r3,|L32.48|
000010  e3510001          CMP      r1,#1                 ;357
000014  e0800003          ADD      r0,r0,r3
000018  05802000          STREQ    r2,[r0,#0]
;;;359        } else {
;;;360            outpw(REG_GPIOA_DIR + offset, 0x0);
00001c  13a01000          MOVNE    r1,#0
000020  15801000          STRNE    r1,[r0,#0]
;;;361        }
;;;362    
;;;363        return SUCCESSFUL;
000024  e3a00000          MOV      r0,#0
;;;364    }
000028  e12fff1e          BX       lr
;;;365    
                          ENDP

                  |L32.44|
                          DCD      ||.data||
                  |L32.48|
                          DCD      0xb8003000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gpioCfg
                          %        164

                          AREA ||.data||, DATA, ALIGN=2

                  maskTbl
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x00007fff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000003f
